<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Study Cards</title>

  <style>
    body{font-family:-apple-system,system-ui,Segoe UI,Roboto;margin:0}
    main{max-width:900px;margin:0 auto;padding:16px}
    h1{font-size:22px;margin:8px 0}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0}
    .card{border:1px solid #ddd;border-radius:14px;padding:16px;box-shadow:0 1px 4px rgba(0,0,0,.04)}
    .title{font-weight:600;margin-bottom:8px}
    .q,.a{font-size:18px;line-height:1.6;word-wrap:break-word}
    button{padding:8px 12px;border-radius:10px;border:1px solid #cfcfcf;background:#fff;cursor:pointer}
    select{padding:6px 10px;border-radius:8px;border:1px solid #cfcfcf}
    hr{border:none;border-top:1px solid #eee;margin:10px 0}
    .leitner{display:flex;gap:8px;margin-top:12px}

    /* Table styling for Markdown tables */
    table{border-collapse:collapse;margin:12px 0;width:100%}
    th,td{border:1px solid #ccc;padding:6px 10px;text-align:left;vertical-align:top}
    th{background:#f5f5f5;font-weight:600}

    /* Responsive tables on small screens */
    .q table,.a table{display:block;overflow-x:auto;-webkit-overflow-scrolling:touch}
  </style>

  <!-- Showdown for Markdown -->
  <script src="https://cdn.jsdelivr.net/npm/showdown@2.1.0/dist/showdown.min.js"></script>

  <!-- MathJax for LaTeX -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  <!-- Highlight.js for syntax colouring -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <!-- Flashcards injected by Streamlit -->
  <script id="cards-data" type="application/json">__CARDS__</script>

  <script>
    /**
     * ---- Config injected by Streamlit ----
     * These placeholders are replaced server-side.
     */
    const API_TOKEN = "__API_TOKEN__";
    const API_BASE  = "__API_BASE__";

    /** Get current profile name from URL (e.g., ?profile=alice). */
    function getProfile(){
      const p = new URLSearchParams(location.search).get("profile");
      return (p && p.trim()) || "default";
    }

    /** Return the server API base URL. */
    function apiBase(){ return API_BASE; }
  </script>

  <script>
    /**
     * -------------------- Progress Sync (Server + Local) --------------------
     */

    /**
     * Fetch progress JSON from server for a profile.
     * Falls back to null if request fails.
     * @param {string} profile
     * @returns {Promise<Object|null>}
     */
    async function fetchProgressServer(profile){
      try{
        const res = await fetch(`${apiBase()}/progress/${encodeURIComponent(profile)}`, { method: "GET" });
        if(!res.ok) throw new Error(`fetch failed (${res.status})`);
        return await res.json();
      }catch(e){
        console.warn("Server fetch failed; falling back to localStorage.", e);
        return null;
      }
    }

    // Debounced save to avoid spamming server
    let saveTimer = null;

    /**
     * Debounced PUT to server with bearer token.
     */
    function saveProgressServerDebounced(profile, data){
      if(saveTimer) clearTimeout(saveTimer);
      saveTimer = setTimeout(async () => {
        try{
          await fetch(`${apiBase()}/progress/${encodeURIComponent(profile)}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${API_TOKEN}`
            },
            body: JSON.stringify(data)
          });
        }catch(e){
          console.warn("Server save failed; localStorage still updated.", e);
        }
      }, 350);
    }

    /**
     * -------------------- Local Storage (profile-scoped) --------------------
     */
    function storageKey(){ return `leitner:${getProfile()}`; }

    /** @returns {Object} */
    function loadProgressLocal(){
      try{ return JSON.parse(localStorage.getItem(storageKey()) || "{}"); }
      catch{ return {}; }
    }

    /** @param {Object} state */
    function saveProgressLocal(state){
      try{ localStorage.setItem(storageKey(), JSON.stringify(state)); }
      catch{}
    }
  </script>

  <script>
    /**
     * -------------------- App Boot + State --------------------
     */

    const CARDS = (() => {
      // Parse safely from the JSON script tag
      const el = document.getElementById("cards-data");
      try{ return JSON.parse(el.textContent) || []; }
      catch{ return []; }
    })();

    // Global state
    let cards = [];   // all cards
    let queue = [];   // filtered & due cards
    let idx = 0;      // index in queue
    let shown = false;// answer visibility
    let prog = {};    // progress map

    // UI elements
    let shuffleEl;

    /**
     * Markdown renderer with options matching GitHub-like flavour.
     * Math is preserved as-is for MathJax to process.
     */
    const fmt = new showdown.Converter({
      tables: true, strikethrough: true, ghCodeBlocks: true,
      literalMidWordUnderscores: true, simpleLineBreaks: true,
      ghCompatibleHeaderId: true
    });
    fmt.addExtension(() => [{
      type: 'lang',
      regex: /\$\$[^]*?\$\$|\$[^$]+\$/g,
      replace: (m) => m
    }]);

    /** Build a stable id for a card. */
    function idOf(c){ return (c.topic||"default")+"::"+(c.tag||"")+"::"+(c.title||"")+"::"+c.q; }

    /** Leitner schedule (days) per box. */
    function schedule(box){ return [0,0,1,3,7,16,35][Math.min(box,6)]; }

    /** In-place shuffle. */
    function shuffleArray(arr){
      for(let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    /** Load Shuffle preference. */
    function loadShufflePref(){
      try{ return localStorage.getItem("rk_shuffle") === "1"; }
      catch{ return false; }
    }

    /** Save Shuffle preference. */
    function saveShufflePref(v){
      try{ localStorage.setItem("rk_shuffle", v ? "1" : "0"); }
      catch{}
    }

    /** Initialise progress from server or local cache. */
    async function initProgress(){
      const server = await fetchProgressServer(getProfile());
      if(server && typeof server === "object"){
        prog = server;
        saveProgressLocal(prog);                // cache locally
      }else{
        prog = loadProgressLocal();             // offline fallback
      }
    }

    /** Persist progress: local immediately + debounced server. */
    function persistProgress(){
      saveProgressLocal(prog);
      saveProgressServerDebounced(getProfile(), prog);
    }

    /**
     * -------------------- Rendering --------------------
     */
    function render(){
      const titleEl = document.getElementById("title");
      const qEl     = document.getElementById("q");
      const aEl     = document.getElementById("a");
      const metaEl  = document.getElementById("meta");
      const progEl  = document.getElementById("progress");

      if(queue.length === 0){
        titleEl.textContent = "";
        qEl.textContent     = "No cards.";
        aEl.textContent     = "";
        metaEl.textContent  = "";
        progEl.textContent  = "";
        return;
      }

      const c  = queue[idx];
      const id = idOf(c);
      const st = prog[id] || { box: 1, last: 0 };

      const dueInMs = schedule(st.box) * 86400 * 1000 - (Date.now() - st.last);
      const days    = dueInMs > 0 ? Math.ceil(dueInMs / 86400 / 1000) : 0;

      titleEl.textContent = (c.topic ? `[${c.topic}] ` : "") + (c.title || "");
      qEl.innerHTML = fmt.makeHtml(c.q);
      aEl.innerHTML = fmt.makeHtml(c.a);

      // code highlight (default to python if not specified)
      document.querySelectorAll("pre code").forEach((block) => {
        if(!block.className.includes("language")){
          block.classList.add("language-python");
        }
        hljs.highlightElement(block);
      });

      aEl.style.display = shown ? "block" : "none";

      metaEl.textContent = `Box: ${st.box} | Next review: ${days===0 ? "due now" : `in ${days} day(s)`}`;
      progEl.textContent = `Card ${idx+1} of ${queue.length} (Topic: ${c.topic||"default"})`;

      if(window.MathJax && window.MathJax.typeset) window.MathJax.typeset();
    }

    /**
     * -------------------- Navigation + Grading --------------------
     */
    function move(d){
      if(!queue.length) return;
      idx = (idx + d + queue.length) % queue.length;
      shown = false;
      render();
    }

    function grade(q){
      if(!queue.length) return;
      const c  = queue[idx];
      const id = idOf(c);
      const st = prog[id] || { box: 1, last: 0 };

      if(q === "again")      st.box = 1;
      else if(q === "hard")  st.box = Math.max(1, st.box);
      else if(q === "good")  st.box = Math.min(6, st.box + 1);
      else if(q === "easy")  st.box = Math.min(6, st.box + 2);

      st.last = Date.now();
      prog[id] = st;
      persistProgress();
      move(1);
    }

    /**
     * -------------------- Filtering --------------------
     */
    function updateTagOptions(){
      const topicSel = document.getElementById("topic").value;
      const tagEl    = document.getElementById("tag");
      const visible  = cards.filter(c => !topicSel || c.topic === topicSel);
      const tags     = [...new Set(visible.map(c => c.tag))].filter(Boolean).sort();
      tagEl.innerHTML = `<option value="">All</option>` + tags.map(t => `<option>${t}</option>`).join("");
    }

    function applyFilters(){
      const topicSel = document.getElementById("topic").value;
      const tagSel   = document.getElementById("tag").value;
      const now      = Date.now();

      const filtered = cards.filter(c => (!topicSel || c.topic === topicSel) && (!tagSel || c.tag === tagSel));

      let due = filtered.filter(c => {
        const st = prog[idOf(c)] || { box: 1, last: 0 };
        const dueTime = st.last + schedule(st.box) * 86400 * 1000;
        return dueTime <= now;
      });

      if(due.length === 0) due = filtered.slice();

      if (shuffleEl.checked && due.length > 1){
        shuffleArray(due);
      }

      queue = due; idx = 0; shown = false; render();

      document.getElementById("progress").textContent =
        `Showing ${queue.length} / ${filtered.length}${shuffleEl.checked ? " (shuffled)" : ""}`;
    }

    /**
     * -------------------- Boot --------------------
     */
    async function boot(){
      // CARDS is an array injected by Streamlit (not wrapped)
      cards = (CARDS || []).slice();

      const topicEl = document.getElementById("topic");
      const topics  = [...new Set(cards.map(c => c.topic || "default"))].sort();
      topicEl.innerHTML = `<option value="">All</option>` + topics.map(t => `<option>${t}</option>`).join("");

      shuffleEl = document.getElementById("shuffle");
      shuffleEl.checked = loadShufflePref();

      await initProgress();
      updateTagOptions();
      applyFilters();
    }

    /**
     * -------------------- Events --------------------
     */
    window.addEventListener("DOMContentLoaded", () => {
      document.getElementById("prev").onclick  = () => move(-1);
      document.getElementById("next").onclick  = () => move(1);
      document.getElementById("show").onclick  = () => { shown = !shown; render(); };
      document.getElementById("again").onclick = () => grade("again");
      document.getElementById("hard").onclick  = () => grade("hard");
      document.getElementById("good").onclick  = () => grade("good");
      document.getElementById("easy").onclick  = () => grade("easy");
      document.getElementById("topic").onchange= () => { updateTagOptions(); applyFilters(); };
      document.getElementById("tag").onchange  = applyFilters;

      // Shuffle preference
      document.getElementById("shuffle").onchange = () => {
        saveShufflePref(document.getElementById("shuffle").checked);
        applyFilters();
      };

      // Reset progress (server + local)
      document.getElementById("resetProg").onclick = () => {
        if(confirm(`Reset progress for "${getProfile()}"? This cannot be undone.`)){
          prog = {};
          persistProgress();
          applyFilters();
          alert("Progress has been reset. All cards are due again.");
        }
      };

      // Initial syntax highlight for any static blocks
      document.querySelectorAll("pre code").forEach(hljs.highlightElement);

      boot();
    });
  </script>
</head>

<body>
  <main>
    <header>
      <h1>FlashCards</h1>
      <div class="controls" role="group" aria-label="Flashcard controls">
        <label for="topic" class="visually-hidden" style="position:absolute;left:-9999px;">Topic</label>
        <select id="topic" aria-label="Topic filter"></select>

        <label for="tag" class="visually-hidden" style="position:absolute;left:-9999px;">Tag</label>
        <select id="tag" aria-label="Tag filter"></select>

        <button id="prev" aria-label="Previous card">Prev</button>
        <button id="show" aria-controls="a" aria-expanded="false">Show / Hide</button>
        <button id="next" aria-label="Next card">Next</button>

        <label style="display:flex;gap:6px;align-items:center;font-size:14px;">
          <input type="checkbox" id="shuffle" />
          Shuffle
        </label>

        <button id="resetProg" title="Clear saved progress">ðŸ”„ Reset Progress</button>
      </div>
      <div id="progress" style="margin:8px 0; font-size:14px; color:#555;"></div>
    </header>

    <section class="card" aria-live="polite">
      <div class="title" id="title"></div>
      <div class="q" id="q"></div>
      <hr/>
      <div class="a" id="a" style="display:none"></div>
      <div id="meta" style="margin-top:10px; font-size:13px; color:#666;"></div>

      <div class="leitner">
        <button id="again">Again</button>
        <button id="hard">Hard</button>
        <button id="good">Good</button>
        <button id="easy">Easy</button>
      </div>
    </section>

    <footer><small>Progress syncs to server (falls back to this device if offline).</small></footer>
  </main>
</body>
</html>
