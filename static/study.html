<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Study Cards</title>

  <style>
    body{font-family:-apple-system,system-ui,Segoe UI,Roboto;margin:0}
    main{max-width:900px;margin:0 auto;padding:16px}
    h1{font-size:22px;margin:8px 0}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0}
    .card{border:1px solid #ddd;border-radius:14px;padding:16px;box-shadow:0 1px 4px rgba(0,0,0,.04)}
    .title{font-weight:600;margin-bottom:8px}
    .q,.a{font-size:18px;line-height:1.6;word-wrap:break-word}
    button{padding:8px 12px;border-radius:10px;border:1px solid #cfcfcf;background:#fff}
    select{padding:6px 10px;border-radius:8px;border:1px solid #cfcfcf}
    hr{border:none;border-top:1px solid #eee;margin:10px 0}
    .leitner{display:flex;gap:8px;margin-top:12px}

     /* Table styling for Markdown tables */
    table {
        border-collapse: collapse;
        margin: 12px 0;
        width: 100%;
    }
    th, td {
        border: 1px solid #ccc;
        padding: 6px 10px;
        text-align: left;
        vertical-align: top;
    }
    th {
        background: #f5f5f5;
        font-weight: 600;
    }

    /* Optional: responsive tables on small screens */
    .q table, .a table {
        display: block;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }
  </style>

  <!-- Showdown for Markdown -->
  <script src="https://cdn.jsdelivr.net/npm/showdown@2.1.0/dist/showdown.min.js"></script>

  <script>
    // -------- sync config --------
    function getProfile() {
      const p = new URLSearchParams(location.search).get("profile");
      return (p && p.trim()) || "default";
    }
   

    async function fetchProgressServer(profile) {
      try {
        const res = await fetch(`${apiBase()}/progress/${encodeURIComponent(profile)}`, { method: "GET" });
        if (!res.ok) throw new Error("fetch failed");
        return await res.json();
      } catch (e) {
        console.warn("Server fetch failed; falling back to localStorage.", e);
        return null; // caller can fall back
      }
    }

    // Debounced save to avoid spamming server
    let saveTimer = null;
    function saveProgressServerDebounced(profile, data) {
      if (saveTimer) clearTimeout(saveTimer);
      saveTimer = setTimeout(async () => {
        try {
          await fetch(`${apiBase()}/progress/${encodeURIComponent(profile)}`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${API_TOKEN}`
            },
            body: JSON.stringify(data)
          });
        } catch (e) {
          console.warn("Server save failed; localStorage still updated.", e);
        }
      }, 350);
    }

    // -------- localStorage (namespaced by profile) --------
    function storageKey() { return `leitner:${getProfile()}`; }
    function loadProgressLocal(){
      try { return JSON.parse(localStorage.getItem(storageKey()) || "{}"); } catch { return {}; }
    }
    function saveProgressLocal(state){
      try { localStorage.setItem(storageKey(), JSON.stringify(state)); } catch {}
    }
  </script>

  <script>
    const API_TOKEN = "__API_TOKEN__";
    const API_BASE = "__API_BASE__";

    function getProfile() {
      const p = new URLSearchParams(location.search).get("profile");
      return (p && p.trim()) || "default";
    }

    function apiBase() {
      return API_BASE;
    }
  </script>

  <!-- MathJax for LaTeX -->
  <script>
  window.MathJax = {
    tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
    svg: { fontCache: 'global' }
  };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <!-- Flashcards injected by Streamlit -->
  <script id="cards-data" type="application/json">__CARDS__</script>
  <script>
  // Parse safely from the JSON script tag
  const CARDS = { cards: JSON.parse(document.getElementById('cards-data').textContent) };
  </script>

  <!-- Highlight.js for syntax colouring -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>
    window.addEventListener("DOMContentLoaded", () => {
      document.querySelectorAll("pre code").forEach((block) => {
        hljs.highlightElement(block);
      });
    });
  </script>

  
</head>
<body>
  <main>
    <header>
      <h1>Study Cards</h1>
      <div class="controls">
        <select id="topic"></select>
        <select id="tag"></select>
        <button id="prev">Prev</button>
        <button id="show">Show / Hide</button>
        <button id="next">Next</button>
         <label style="display:flex;gap:6px;align-items:center;font-size:14px;">
            <input type="checkbox" id="shuffle" />
            Shuffle
          </label>
        <button id="resetProg" title="Clear saved progress">ðŸ”„ Reset Progress</button>
      </div>
      <div id="progress" style="margin:8px 0; font-size:14px; color:#555;"></div>
    </header>

    <section class="card">
      <div class="title" id="title"></div>
      <div class="q" id="q"></div>
      <hr/>
      <div class="a" id="a" style="display:none"></div>
      <div id="meta" style="margin-top:10px; font-size:13px; color:#666;"></div>

      <div class="leitner">
        <button id="again">Again</button>
        <button id="hard">Hard</button>
        <button id="good">Good</button>
        <button id="easy">Easy</button>
      </div>
    </section>
    <footer><small>Progress syncs to server (falls back to this device if offline).</small></footer>

  </main>

  <script>
  // === global state ===
  let cards=[], queue=[], idx=0, shown=false;

  const shuffleEl = document.getElementById("shuffle");

  // Markdown renderer
  const fmt = new showdown.Converter({
    tables: true, strikethrough: true, ghCodeBlocks: true,
    literalMidWordUnderscores: true, simpleLineBreaks: true,
    ghCompatibleHeaderId: true  
  });
  fmt.addExtension(() => [{
    type: 'lang',
    regex: /\$\$[^]*?\$\$|\$[^$]+\$/g,
    replace: (m) => m
  }]);

  // --- helpers ---
  function idOf(c){ return (c.topic||"default")+"::"+(c.tag||"")+"::"+(c.title||"")+"::"+c.q; }
  function schedule(box){ return [0,0,1,3,7,16,35][Math.min(box,6)]; }

  // Shuffle helpers + preference
  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  function loadShufflePref() {
    try { return localStorage.getItem("rk_shuffle") === "1"; } catch { return false; }
  }
  function saveShufflePref(v) {
    try { localStorage.setItem("rk_shuffle", v ? "1" : "0"); } catch {}
  }

  // --- profile-scoped local cache ---
  function storageKey() { return `leitner:${getProfile()}`; }
  function loadProgressLocal(){ try { return JSON.parse(localStorage.getItem(storageKey()) || "{}"); } catch { return {}; } }
  function saveProgressLocal(state){ try { localStorage.setItem(storageKey(), JSON.stringify(state)); } catch {} }

  // --- hybrid progress (server + local) ---
  let prog = {};  // global progress

  async function initProgress() {
    const server = await fetchProgressServer(getProfile());
    if (server && typeof server === "object") {
      prog = server;
      saveProgressLocal(prog);               // cache locally
    } else {
      prog = loadProgressLocal();            // offline fallback
    }
  }

  // debounced server save
  function persistProgress() {
    saveProgressLocal(prog);                 // immediate local cache
    saveProgressServerDebounced(getProfile(), prog); // async server save
  }

  // --- rendering ---
  function render(){
    if (queue.length===0){
      document.getElementById("title").textContent="";
      document.getElementById("q").textContent="No cards.";
      document.getElementById("a").textContent="";
      document.getElementById("meta").textContent="";
      document.getElementById("progress").textContent="";
      return;
    }
    const c=queue[idx]; const id=idOf(c); const st=prog[id]||{box:1,last:0};
    const dueIn=schedule(st.box)*86400*1000-(Date.now()-st.last);
    const days=dueIn>0?Math.ceil(dueIn/86400/1000):0;

    document.getElementById("title").textContent=(c.topic?`[${c.topic}] `:"")+(c.title||"");
    document.getElementById("q").innerHTML=fmt.makeHtml(c.q);
    document.getElementById("a").innerHTML=fmt.makeHtml(c.a);
    //Highlight code blocks after rendering
    document.querySelectorAll("pre code").forEach((block) => {
      if (!block.className.includes("language")) {
        block.classList.add("language-python"); // default to python if not specified
      }
      hljs.highlightElement(block);
    });

    document.getElementById("a").style.display=shown?"block":"none";

    document.getElementById("meta").textContent=`Box: ${st.box} | Next review: ${days===0?"due now":"in "+days+" day(s)"}`;
    document.getElementById("progress").textContent=`Card ${idx+1} of ${queue.length} (Topic: ${c.topic||"default"})`;

    if(window.MathJax && window.MathJax.typeset) window.MathJax.typeset();
  }

  // --- navigation + grading ---
  function move(d){ if(queue.length){ idx=(idx+d+queue.length)%queue.length; shown=false; render(); } }
  function grade(q){ if(!queue.length) return;
    const c=queue[idx]; const id=idOf(c); const st=prog[id]||{box:1,last:0};
    if(q==="again") st.box=1;
    else if(q==="hard") st.box=Math.max(1,st.box);
    else if(q==="good") st.box=Math.min(6,st.box+1);
    else if(q==="easy") st.box=Math.min(6,st.box+2);

    st.last=Date.now();
    prog[id]=st;
    persistProgress();      // server + local
    move(1);
  }

  // --- filtering ---
  function updateTagOptions(){
    const topicSel=document.getElementById("topic").value;
    const tagEl=document.getElementById("tag");
    const visible=cards.filter(c=>!topicSel||c.topic===topicSel);
    const tags=[...new Set(visible.map(c=>c.tag))].filter(Boolean).sort();
    tagEl.innerHTML=`<option value="">All</option>`+tags.map(t=>`<option>${t}</option>`).join("");
  }

  function applyFilters(){
    const topicSel=document.getElementById("topic").value;
    const tagSel=document.getElementById("tag").value;
    const now=Date.now();

    const filtered=cards.filter(c=>(!topicSel||c.topic===topicSel)&&(!tagSel||c.tag===tagSel));

    let due=filtered.filter(c=>{
      const st=prog[idOf(c)]||{box:1,last:0};
      const dueTime=st.last+schedule(st.box)*86400*1000;
      return dueTime<=now;
    });
    if(due.length===0) due=filtered.slice();

    if (shuffleEl.checked && due.length>1) {
      shuffleArray(due);
    }

    queue=due; idx=0; shown=false; render();

    document.getElementById("progress").textContent =
      `Showing ${queue.length} / ${filtered.length}${shuffleEl.checked ? " (shuffled)" : ""}`;
  }

  // --- boot ---
  async function boot(){
    cards=(CARDS.cards||[]).slice();
    const topicEl=document.getElementById("topic");
    const topics=[...new Set(cards.map(c=>c.topic||"default"))].sort();
    topicEl.innerHTML=`<option value="">All</option>`+topics.map(t=>`<option>${t}</option>`).join("");

    shuffleEl.checked = loadShufflePref();

    await initProgress(); 
    updateTagOptions();
    applyFilters();
  }

  // --- events ---
  document.getElementById("prev").onclick=()=>move(-1);
  document.getElementById("next").onclick=()=>move(1);
  document.getElementById("show").onclick=()=>{ shown=!shown; render(); };
  document.getElementById("again").onclick=()=>grade("again");
  document.getElementById("hard").onclick=()=>grade("hard");
  document.getElementById("good").onclick=()=>grade("good");
  document.getElementById("easy").onclick=()=>grade("easy");
  document.getElementById("topic").onchange=()=>{ updateTagOptions(); applyFilters(); };
  document.getElementById("tag").onchange=applyFilters;
  shuffleEl.onchange=()=>{ saveShufflePref(shuffleEl.checked); applyFilters(); };

  // Reset progress (server + local)
  document.getElementById("resetProg").onclick = () => {
    if (confirm(`Reset progress for "${getProfile()}"? This cannot be undone.`)) {
      prog = {};
      persistProgress();
      applyFilters();
      alert("Progress has been reset. All cards are due again.");
    }
  };

  boot();
</script>

</body>
</html>
